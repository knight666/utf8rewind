/*! @page examples Examples

@tableofcontents

@section example-changes Changes to existing code

Suppose you maintain a client application written in C. In order for clients to login, the application needs to check their credentials. This is accomplished by the following function:

@code{.c}
	int Login_CheckCredentials(const char* username, const char* password)
	{
		const char* salt;
		const char* hashed_password;
		char verify_password[256] = { 0 };
		char hashed_verify_password[256] = { 0 };

		/* For the purposes of brevity, ignore the fact
		that this is a terrible way to generate a salt,
		because it has insufficient entropy. */
		salt = md5(username);

		hashed_password = md5(password);
		strcat(verify_password, hashed_password);
		strcat(verify_password, salt);

		strcpy(hashed_verify_password, md5(verify_password));

		return Database_CheckLogin(username, hashed_verify_password);
	}
@endcode

Now we want to improve our security by allowing the full range of Unicode in the passwords by using UTF-8 encoding.

What would we have to change? Nothing at all.

A password like \"M&ocirc;ntiPyth&ocirc;nikdenH&ocirc;lieGr&acirc;ilen\" would be encoded as `M\xF8Pyth\xF8denH\xF8Gr\xE4en`, meaning the calls to `strcat` and `strcpy` would still work as intended. The password can be treated as ASCII without changing the code.

When converting your project to use UTF-8, you only have to worry about two surface areas: input and display. Let's look at those separately.

@section example-user-input Dealing with user input

Continuing with the previous example, the old password field accepted only ASCII input:

@code{.c}
	static const int g_PasswordInputMaximum = 255;
	static char g_PasswordInput[g_PasswordInputMaximum + 1];

	int PasswordField_EnterCharacter(char input)
	{
		char text_input[2] = { input, 0 };
		
		if ((strlen(g_PasswordInput) + 1) > g_PasswordInputMaximum)
		{
			return 0;
		}
		
		strcat(g_PasswordInput, text_input);

		return 1;
	}
@endcode

We'll have to make sure that we provide UTF-32 codepoints instead:

@code{.c}
	int PasswordField_EnterCharacter(unicode_t input)
@endcode

This can be accomplished using a simple cast, because all ASCII codepoints fit in a `unicode_t` type.

Next, we'll have to increase the size of the `text_input` string in order to accommodate the conversion of the codepoint to UTF-8. Finally, we use the utf32toutf8() function to convert the input to UTF-8.

@code{.c}
	char text_input[16] = { 0 };
	int32_t errors = 0;
	
	utf32toutf8(&input, sizeof(unicode_t), text_input, 16, &errors);
	if (errors != 0)
	{
		return 0;
	}
@endcode

Because the codepoint can consist of multiple characters, we'll have to change the check to see if we're not overflowing the password input string:

@code{.c}
	if ((strlen(g_PasswordInput) + strlen(text_input)) > g_PasswordInputMaximum)
	{
		return 0;
	}
@endcode

Putting it all together again:

@code{.c}
	static const int g_PasswordInputMaximum = 255;
	static char g_PasswordInput[g_PasswordInputMaximum + 1];

	int PasswordField_EnterCharacter(unicode_t input)
	{
		char text_input[16] = { 0 };
		int32_t errors = 0;
	
		utf32toutf8(&input, sizeof(unicode_t), text_input, 16, &errors);
		if (errors != 0)
		{
			return 0;
		}
		
		if ((strlen(g_PasswordInput) + strlen(text_input)) > g_PasswordInputMaximum)
		{
			return 0;
		}
		
		strcat(g_PasswordInput, text_input);

		return 1;
	}
@endcode

With a few changes, the password field now accepts UTF-8 input. The benefit here is that we didn't need to change the algorithm itself, only the input had to be converted.

@section example-display Displaying Unicode text

One problem remains: the user may be able to *enter* Unicode characters in text fields, but they won't show up right.

Let's look at the offending function:

@code{.c}
	void InputField_Draw(int x, int y, const char* text)
	{
		size_t i;
		const char* src = text;
		
		FontBatch_Start("Arial20");
		
		for (i = 0; i < strlen(text); ++i)
		{
			FontBatch_AddCharacter(*src);
			
			src++;
		}
		
		FontBatch_End();
		FontBatch_Draw(x, y);
	}
@endcode

The first thing that will have to change is that `FontBatch_AddCharacter` should accept UTF-32 codepoints. Fortunately, that change is backwards-compatible:

@code{.c}
	FontBatch_AddCharacter((unicode_t)*src);
@endcode

Next, we'll have to treat the input as UTF-8 encoded text. We'll have to convert the string to UTF-32. For that, we'll use the utf8toutf32() function.

@code{.c}
	int32_t errors = 0;
	char* converted = 0;
	
	size_t converted_size = utf8toutf32(text, strlen(text), 0, 0, &errors);
	if (errors != 0)
	{
		goto error;
	}
	
	converted = (char*)malloc(converted_size);
	utf8toutf32(text, strlen(text), converted, converted_size, &errors);
	if (errors != 0)
	{
		goto error;
	}
	
error:
	if (converted != 0)
	{
		free(converted);
		converted = 0;
	}
@endcode

Putting it all together again:

@code{.c}
	void InputField_Draw(int x, int y, const char* text)
	{
		int32_t errors = 0;
		char* converted = 0;
		size_t converted_length = 0;
		size_t i;
		
		size_t converted_size = utf8toutf32(text, strlen(text), 0, 0, &errors);
		if (errors != 0)
		{
			goto error;
		}
		
		converted = (char*)malloc(converted_size);
		utf8toutf32(text, strlen(text), converted, converted_size, &errors);
		if (errors != 0)
		{
			goto error;
		}
		
		converted_length = converted_size / sizeof(unicode_t);
		
		FontBatch_Start("Arial20");
		
		for (i = 0; i < converted_length; ++i)
		{
			FontBatch_AddCharacter(converted[i]);
		}
		
		FontBatch_End();
		FontBatch_Draw(x, y);
		
	error:
		if (converted != 0)
		{
			free(converted);
			converted = 0;
		}
	}
@endcode

As you can see, it's relatively simple to convert a program to use UTF-8 after the fact, because it's backwards-compatible with ASCII-encoded text.

@section example-interfacing Interfacing with third-party libraries

When working with localized text, you often have to interface with existing libraries. On Windows especially, the API's expect either ASCII or UTF-16 encoded text. Luckily, `utf8rewind` comes with tools to handle these situations.

For example, let's say you're building a game and you want to store a player's progress in a savefile. To guarantee that the file is unique, you use the player's name in the filename.

In this example, we're already using `utf8rewind` to deal with encoded text. The only issue remaining is actually opening the file and saving the progress. We use the following interface:

@code{.c}
	int32_t Save_WriteGameState(const char* playerName, GameState* state);
@endcode

Using the Windows API, here's how we can construct the path and open the file for writing:

@code{.c}
	int32_t Save_WriteGameState(const char* playerName, GameState* state)
	{
		int32_t result = 0;
		wchar_t* my_documents = NULL;
		wchar_t full_path[_MAX_PATH] = { 0 };
		wchar_t* wide_game_name = L"Example";
		// TODO: Convert player name.
		wchar_t* wide_player_name = L"";
		HANDLE file_handle = INVALID_HANDLE_VALUE;
		
		// retrieve path to "My Documents"
		
		if (FAILED(::SHGetKnownFolderPath(FOLDERID_Documents, 0, NULL, &my_documents)))
		{
			goto cleanup;
		}
		
		// construct path to game folder
		
		wcscat(full_path, my_documents);
		wcscat(full_path, L"\\");
		wcscat(full_path, L"My Games\\");
		wcscat(full_path, wide_game_name);
		wcscat(full_path, L"\\");
		
		// the path should now look similar to this:
		// L"C:/Users/Quinten/Documents/My Games/Example/"
		
		// ensure that the directory exists before trying to create the file
		::CreateDirectoryW(full_path, NULL);
		
		wcscat(full_path, wide_player_name);
		wcscat(full_path, L".sav");
		
		// the complete path:
		// L"C:/Users/Quinten/Documents/My Games/Example/Quinten.sav"
		
		file_handle = ::CreateFileW(
			full_path,
			GENERIC_WRITE,
			FILE_SHARE_READ,
			NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			0
		);
		if (file_handle == INVALID_HANDLE_VALUE)
		{
			goto cleanup;
		}
		
		result = Save_WriteGameStateToFile(file_handle, state);
		
	cleanup:
		return result;
	}
@endcode

Unfortunately, there's still a `TODO` comment at the top. We can use utf8towide() to convert the player name to wide encoding, independent of platform.

@code{.c}
	int32_t errors = 0;
	wchar_t* wide_player_name = NULL;
	size_t wide_player_name_length = 0;
	
	wide_player_name_length = utf8towide(playerName, strlen(playerName), 0, 0, &errors);
	if (errors != 0)
	{
		goto cleanup;
	}
	
	wide_player_name = (wchar_t*)malloc((wide_player_name_length + 1) * sizeof(wchar_t));
	memset(wide_player_name, 0, (wide_player_name_length + 1) * sizeof(wchar_t));
	
	utf8towide(playerName, strlen(playerName), wide_player_name, wide_player_name_length, &errors);
	if (errors != 0)
	{
		goto cleanup;
	}
	
cleanup:
	if (wide_player_name != NULL)
	{
		free(wide_player_name);
		wide_player_name = NULL;
	}
@endcode

Integrated with the rest of the function:

@code{.c}
	int32_t Save_WriteGameState(const char* playerName, GameState* state)
	{
		int32_t result = 0;
		int32_t errors = 0;
		wchar_t* my_documents = NULL;
		wchar_t full_path[_MAX_PATH] = { 0 };
		wchar_t* wide_game_name = L"Example";
		wchar_t* wide_player_name = NULL;
		size_t wide_player_name_length = 0;
		HANDLE file_handle = INVALID_HANDLE_VALUE;
		
		// convert player name to wide string
		
		wide_player_name_length = utf8towide(playerName, strlen(playerName), 0, 0, &errors);
		if (errors != 0)
		{
			goto cleanup;
		}
		
		wide_player_name = (wchar_t*)malloc((wide_player_name_length + 1) * sizeof(wchar_t));
		memset(wide_player_name, 0, (wide_player_name_length + 1) * sizeof(wchar_t));
		
		utf8towide(playerName, strlen(playerName), wide_player_name, wide_player_name_length, &errors);
		if (errors != 0)
		{
			goto cleanup;
		}
		
		// retrieve path to "My Documents"
		
		if (FAILED(::SHGetKnownFolderPath(FOLDERID_Documents, 0, NULL, &my_documents)))
		{
			goto cleanup;
		}
		
		// construct path to game folder
		
		wcscat(full_path, my_documents);
		wcscat(full_path, L"\\");
		wcscat(full_path, L"My Games\\");
		wcscat(full_path, wide_game_name);
		wcscat(full_path, L"\\");
		
		// the path should now look similar to this:
		// L"C:/Users/Quinten/Documents/My Games/Example/"
		
		// ensure that the directory exists before trying to create the file
		::CreateDirectoryW(full_path, NULL);
		
		wcscat(full_path, wide_player_name);
		wcscat(full_path, L".sav");
		
		// the complete path:
		// L"C:/Users/Quinten/Documents/My Games/Example/Quinten.sav"
		
		file_handle = ::CreateFileW(
			full_path,
			GENERIC_WRITE,
			FILE_SHARE_READ,
			NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			0
		);
		if (file_handle == INVALID_HANDLE_VALUE)
		{
			goto cleanup;
		}
		
		result = Save_WriteGameStateToFile(file_handle, state);
	
	cleanup:
		if (wide_player_name != NULL)
		{
			free(wide_player_name);
			wide_player_name = NULL;
		}
		
		return result;
	}
@endcode
*/