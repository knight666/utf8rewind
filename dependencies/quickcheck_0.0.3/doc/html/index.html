<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>QuickCheck++: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QuickCheck++
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">Automated testing library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">QuickCheck++ Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="toc"></a>
Table of Contents</h1>
<ul>
<li><a class="el" href="index.html#introduction">Introduction</a><ul>
<li><a class="el" href="index.html#what">What is QuickCheck++</a></li>
<li><a class="el" href="index.html#why">Why Would I Want to Use It?</a></li>
<li><a class="el" href="index.html#how">How to Get It?</a></li>
<li><a class="el" href="index.html#relation">Relation to Haskell's QuickCheck</a></li>
<li><a class="el" href="index.html#license">License</a></li>
</ul>
</li>
<li><a class="el" href="index.html#using">Using QuickCheck++</a><ul>
<li><a class="el" href="index.html#defining">Defining Properties</a></li>
<li><a class="el" href="index.html#verifying">Verifying Properties</a></li>
<li><a class="el" href="index.html#specifying">Specifying a Precondition</a></li>
<li><a class="el" href="index.html#inspecting">Inspecting Input Data Distribution</a></li>
<li><a class="el" href="index.html#custom">Custom Data Generators</a><ul>
<li><a class="el" href="index.html#general">General Purpose Generators</a></li>
<li><a class="el" href="index.html#special">Special Purpose Generators</a></li>
<li><a class="el" href="index.html#data">Data Generator Primitives</a></li>
</ul>
</li>
<li><a class="el" href="index.html#printing">Printing Property Names</a></li>
<li><a class="el" href="index.html#verbose">Verbose Checking</a></li>
<li><a class="el" href="index.html#fixed">Fixed Test Cases</a></li>
</ul>
</li>
<li><a class="el" href="index.html#how2">How to Contribute?</a><ul>
<li><a class="el" href="index.html#test">Test</a></li>
<li><a class="el" href="index.html#code">Code</a></li>
<li><a class="el" href="index.html#promote">Promote</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="introduction"></a>
Introduction</h1>
<h2><a class="anchor" id="what"></a>
What is QuickCheck++</h2>
<p>QuickCheck++ is a tool for testing C++ programs automatically, inspired by <a href="http://www.cse.chalmers.se/~rjmh/QuickCheck/">QuickCheck</a>, a similar library for Haskell programs.</p>
<p>In QuickCheck++, the application programmer provides a specification of parts of its code in the form of <em>properties</em> which this code must satisfy. Then, the QuickCheck++ utilities can check that these properties holds in a large number of randomly generated test cases.</p>
<p>Specifications, <em>i.e.</em> properties, are written in C++ by deriving from the <a class="el" href="classquickcheck_1_1Property.html" title="5-argument property. ">quickcheck::Property</a> class. This class contains members not only to express the specification but also to observe the distribution of test data and to write custom test data generators.</p>
<p>The framework also allows the specification of <a class="el" href="index.html#fixed">fixed test data</a>, as can be done with more traditional unit testing frameworks.</p>
<dl class="section warning"><dt>Warning</dt><dd>QuickCheck++ has been around since a few years now, but should still be considered an experimental, best-effort project. It comes with absolutely no warranty, see <a class="el" href="index.html#license">License</a> for detail.</dd></dl>
<h2><a class="anchor" id="why"></a>
Why Would I Want to Use QuickCheck++?</h2>
<p>Because you believe in test-driven development to provide better-designed, more robust, self-documented software. Moreover, you like:</p><ul>
<li>precise, formal specifications rather than a few ad-hoc test cases ;</li>
<li>running hundreds of tests cases without having to write them down first ;</li>
<li>reduce the risk of writing test cases with the same bias as when writing the code (<em>e.g.</em> QuickCheck++ will not let you write every test cases of a factorial function with only positive arguments when it also accepts (and crash with) negative ones).</li>
</ul>
<h2><a class="anchor" id="how"></a>
How to Get QuickCheck++?</h2>
<p>Last released version of QuickCheck++ is available from <a href="http://software.legiasoft.com/archives/quickcheck_0.0.3.tar.bz2">http://software.legiasoft.com/archives/quickcheck_0.0.3.tar.bz2</a> while current development version is available through <code>git:</code> </p>
<pre class="fragment">git clone http://software.legiasoft.com/git/quickcheck.git
</pre><h2><a class="anchor" id="relation"></a>
Relation to Haskell's QuickCheck</h2>
<p>Although QuickCheck++ was inspired by Haskell's QuickCheck, it is very loosely related, both from user and implementation points of view. We did not tried to mimic QuickCheck Haskell implementation in C++ and the interface is also very different.</p>
<p>We choose a more traditional, imperative implementation, both due to lack of sufficient knowledge in C++, and to the feeling it would have been awkward to use. We would however be delighted to be proved wrong and would welcome a more elegant, functional implementation.</p>
<p>As we are new to C++ (and hacked this quickly), our imperative implementation could also be seriously improved. We welcome patches for this one as well.</p>
<h2><a class="anchor" id="license"></a>
License</h2>
<p><em>QuickCheck++ is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</em></p>
<p><em>QuickCheck++ is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</em></p>
<p><em>You should have received a copy of the GNU General Public License along with QuickCheck++. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</em></p>
<p>We choose GPLv3 because we have a strong commitment towards free software. However, if you feel this license is overly restrictive and inadequate for your usage, we are willing to hear your arguments.</p>
<h1><a class="anchor" id="using"></a>
Using QuickCheck++</h1>
<p>You can find all the examples given in this section in the file <code>examples.cc</code> provided with QuickCheck++.</p>
<p>To use QuickCheck++, you must include <code><a class="el" href="quickcheck_8hh.html" title="QuickCheck++ utility header. ">quickcheck/quickcheck.hh</a></code> and optionally use the <a class="el" href="namespacequickcheck.html" title="All classes, data generators and printers exported by QuickCheck++ are in the quickcheck namespace...">quickcheck</a> namespace.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="quickcheck_8hh.html">quickcheck/quickcheck.hh</a>&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacequickcheck.html">quickcheck</a>;</div>
</div><!-- fragment --><h2><a class="anchor" id="defining"></a>
Defining Properties</h2>
<p>You can specify a property by deriving the <a class="el" href="classquickcheck_1_1Property.html" title="5-argument property. ">quickcheck::Property</a> class and implementing its <a class="el" href="classquickcheck_1_1Property.html#a801a11022c75d93af5f0a5a161b4a52c" title="Tells whether or not this property holds for the given input. ">quickcheck::Property::holdsFor</a> method.</p>
<p>Here is a simple example. Lets assume you just wrote a function to reverse a sequence for a type named <code>Vector</code>. A property of a reverse function is that if you apply it to a vector twice, you should get back the original vector. With QuickCheck++, this property of your reverse function can be expressed as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PReverseCancelsReverse : <span class="keyword">public</span> Property&lt;Vector&gt; {</div>
<div class="line">   <span class="keywordtype">bool</span> holdsFor(<span class="keyword">const</span> Vector&amp; xs) {</div>
<div class="line">      Vector ys = xs;</div>
<div class="line">      reverse(ys);</div>
<div class="line">      reverse(ys);</div>
<div class="line">      <span class="keywordflow">return</span> xs == ys;</div>
<div class="line">   }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The property is a class deriving from <a class="el" href="classquickcheck_1_1Property.html" title="5-argument property. ">quickcheck::Property</a>, specifying the argument type (here <code>Vector</code>). This class must implement <a class="el" href="classquickcheck_1_1Property.html#a801a11022c75d93af5f0a5a161b4a52c" title="Tells whether or not this property holds for the given input. ">quickcheck::Property::holdsFor</a> which takes a const reference to the type used when deriving <a class="el" href="classquickcheck_1_1Property.html" title="5-argument property. ">quickcheck::Property</a>, and returns <code>true</code> when the property holds for the given input argument (and <code>false</code> otherwise).</p>
<h2><a class="anchor" id="verifying"></a>
Verifying Properties</h2>
<p>To verify a property, simply instantiate it and call its <a class="el" href="classquickcheck_1_1PropertyBase.html#af3c938e7c6d91cb2acc7a5f46bcd2ee0" title="Checks this property. ">quickcheck::Property::check</a> method.</p>
<div class="fragment"><div class="line">PReverseCancelsReverse revRev;</div>
<div class="line">revRev.check();</div>
</div><!-- fragment --><p>This will output:</p>
<pre class="fragment">OK, passed 100 tests.
</pre><p>You can specify the number of random tests to run as the first <a class="el" href="classquickcheck_1_1PropertyBase.html#af3c938e7c6d91cb2acc7a5f46bcd2ee0" title="Checks this property. ">quickcheck::Property::check</a> argument.</p>
<div class="fragment"><div class="line">revRev.check(300);</div>
</div><!-- fragment --><p>would output</p>
<pre class="fragment">OK, passed 300 tests.
</pre><p>In case of failure, QuickCheck++ will display the faulty input, <em>e.g.</em></p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PReverseIsIdentity : <span class="keyword">public</span> Property&lt;Vector&gt; {</div>
<div class="line">   <span class="keywordtype">bool</span> holdsFor(<span class="keyword">const</span> Vector&amp; xs) {</div>
<div class="line">      Vector ys = xs;</div>
<div class="line">      reverse(ys);  <span class="comment">// reverse done only once!</span></div>
<div class="line">      <span class="keywordflow">return</span> xs == ys;</div>
<div class="line">   }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">PReverseIsIdentity revId;</div>
<div class="line">revId.check();</div>
</div><!-- fragment --><p>will output something in the line of:</p>
<pre class="fragment">Falsifiable after 2 tests for input:
  0: [-2, 1]
</pre><p>On average, QuickCheck++ tries shorter arguments first, so that the faulty input is easier to read and to use for debug.</p>
<h2><a class="anchor" id="specifying"></a>
Specifying a Precondition</h2>
<p>Imagine you want to test an insertion function that should insert an element at the right place in a sorted vector. You can express the fact that your insert function preserves the fact that the vector is sorted as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PInsertKeepsSorted : <span class="keyword">public</span> Property&lt;Elem, Vector&gt; {</div>
<div class="line">   <span class="keywordtype">bool</span> holdsFor(<span class="keyword">const</span> Elem&amp; x, <span class="keyword">const</span> Vector&amp; xs) {</div>
<div class="line">      Vector ys = xs;</div>
<div class="line">      insert(x, ys);</div>
<div class="line">      <span class="keywordflow">return</span> isSorted(ys);</div>
<div class="line">   }</div>
<div class="line">};</div>
</div><!-- fragment --><p>However, if you try to verify this property as is, it will not work:</p>
<pre class="fragment">Falsifiable after 5 tests for input:
  0: 2
  1: [-4, 1, -3]
</pre><p>The problem is that nothing enforces the fact that the input vector should be sorted.</p>
<p>This can be specified as part of the property in the form of a predicate on input arguments. Only tests for which the randomly generated arguments satisfies the predicate will be taken into account. The method that acts as predicate is <a class="el" href="classquickcheck_1_1Property.html#a051015d507fbd4147dde44f43174b719" title="Tells whether or not this property should accept given arguments. ">quickcheck::Property::accepts</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PInsertKeepsSorted2 : <span class="keyword">public</span> Property&lt;Elem, Vector&gt; {</div>
<div class="line">   <span class="keywordtype">bool</span> holdsFor(<span class="keyword">const</span> Elem&amp; x, <span class="keyword">const</span> Vector&amp; xs) {</div>
<div class="line">      Vector ys = xs;</div>
<div class="line">      insert(x, ys);</div>
<div class="line">      <span class="keywordflow">return</span> isSorted(ys);</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordtype">bool</span> accepts(<span class="keyword">const</span> Elem&amp; x, <span class="keyword">const</span> Vector&amp; xs) {</div>
<div class="line">      <span class="keywordflow">return</span> isSorted(xs);</div>
<div class="line">   }</div>
<div class="line">};</div>
</div><!-- fragment --><p>However, if you try to check this property with default parameters, you will still observe problems, <em>i.e.</em></p>
<pre class="fragment">Arguments exhausted after 66 tests.
</pre><p>To avoid looping indefinitely in the case the given predicate is never (or rarely) met, QuickCheck++ only tries a finite number of times to generate valid test cases. In our example, QuickCheck++ was only able to generate 66 valid test cases with the default allowed number of attempts (which is 5 times the number of tests to run).</p>
<p>You can increase the number of allowed attempts to generate valid input arguments by specifying a second argument when calling <a class="el" href="classquickcheck_1_1PropertyBase.html#af3c938e7c6d91cb2acc7a5f46bcd2ee0" title="Checks this property. ">quickcheck::Property::check</a>.</p>
<div class="fragment"><div class="line">PInsertKeepsSorted2 insertKeepsSorted2;</div>
<div class="line">insertKeepsSorted2.check(100, 2000);</div>
</div><!-- fragment --><p>gives</p>
<pre class="fragment">OK, passed 100 tests.
</pre><p>However, if you need to increase this number of attempts to make your tests successful, you should carefully inspect the input data distribution (as explained in the next section). It is often the sign that you need a <a class="el" href="index.html#custom">custom input data generator</a>.</p>
<h2><a class="anchor" id="inspecting"></a>
Inspecting Input Data Distribution</h2>
<p>When dealing with randomly generated test cases, it is often important to be able to inspect input data distribution. This allows to check that all <em>interesting</em> cases have been covered, and that no bias is introduced due to an <a class="el" href="index.html#specifying">input predicate</a> or a bad <a class="el" href="index.html#custom">generator</a>.</p>
<p>The simplest tool provided by QuickCheck++ for input data inspection is the <a class="el" href="classquickcheck_1_1Property.html#a7c1bc22d087ddf84190be4a608ff5d5c" title="Tells whether or not the property is trivially true for the given input. ">quickcheck::Property::isTrivialFor</a> predicate. This predicate should return <code>true</code> when the input data makes the property trivially true.</p>
<p>For example, if we return to our <a class="el" href="index.html#defining">PReverseCancelsReverse</a> example, we could consider that the property is trivially true for empty vectors and for vectors of only one element.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PReverseCancelsReverse2 : <span class="keyword">public</span> Property&lt;Vector&gt; {</div>
<div class="line">   <span class="keywordtype">bool</span> holdsFor(<span class="keyword">const</span> Vector&amp; xs) {</div>
<div class="line">      Vector ys = xs;</div>
<div class="line">      reverse(ys);</div>
<div class="line">      reverse(ys);</div>
<div class="line">      <span class="keywordflow">return</span> xs == ys;</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordtype">bool</span> isTrivialFor(<span class="keyword">const</span> Vector&amp; xs) {</div>
<div class="line">      <span class="keywordflow">return</span> xs.size() &lt; 2;</div>
<div class="line">   }</div>
<div class="line">};</div>
</div><!-- fragment --><p>When we check this property, QuickCheck++ reports the proportion of test cases that were <em>trivial</em>.</p>
<pre class="fragment">OK, passed 100 tests (12% trivial).
</pre><p>This information reassures us on the fact that both trivial and non-trivial cases were tested (with a sufficient number of the later).</p>
<p>Another, more powerful tool to inspect input data distribution is the <a class="el" href="classquickcheck_1_1Property.html#a22144bc11b49d0d20fe1e25f5f0b4073" title="Classifies input to allow observation of input distribution. ">quickcheck::Property::classify</a> method which assigns a tag to any combination of input arguments. When a classifier is defined, QuickCheck++ displays the distribution of test cases amongst the tags after the test result.</p>
<p>For example, let's inspect our insertion test to ensure we test both insertions at head of the vector, at end of vector, and of course inside vector.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PInsertKeepsSorted3 : <span class="keyword">public</span> Property&lt;Elem, Vector&gt; {</div>
<div class="line">   <span class="keywordtype">bool</span> holdsFor(<span class="keyword">const</span> Elem&amp; x, <span class="keyword">const</span> Vector&amp; xs) {</div>
<div class="line">      Vector ys = xs;</div>
<div class="line">      insert(x, ys);</div>
<div class="line">      <span class="keywordflow">return</span> isSorted(ys);</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordtype">bool</span> accepts(<span class="keyword">const</span> Elem&amp; x, <span class="keyword">const</span> Vector&amp; xs) {</div>
<div class="line">      <span class="keywordflow">return</span> isSorted(xs);</div>
<div class="line">   }</div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">string</span> classify(<span class="keyword">const</span> Elem&amp; x, <span class="keyword">const</span> Vector&amp; xs) {</div>
<div class="line">      <span class="keywordflow">if</span> (xs.empty())</div>
<div class="line">         <span class="keywordflow">return</span> <span class="stringliteral">&quot;in empty&quot;</span>;</div>
<div class="line">      <span class="keywordflow">if</span> (x &lt; xs[0])</div>
<div class="line">         <span class="keywordflow">return</span> <span class="stringliteral">&quot;at head&quot;</span>;</div>
<div class="line">      <span class="keywordflow">if</span> (x &gt; xs.back())</div>
<div class="line">         <span class="keywordflow">return</span> <span class="stringliteral">&quot;at end&quot;</span>;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="stringliteral">&quot;inside&quot;</span>;</div>
<div class="line">   }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Our 100 tests (with a maximum of 2000 attempts) now gives:</p>
<pre class="fragment">OK, passed 100 tests.
  34% in empty
  32% at end
  18% at head
  16% inside
</pre><p>We observe that more than a third of the tests concerned the insertion into an empty vector and that only 16% of the tests were inserting inside the vector. This indicates that the combination of the default input data generator and input predicate induce a bias in our test cases.</p>
<p>We can further inspect generated data by adding the length of the input vector to the tag. This is equivalent to the <code>collect</code> combinator in original Haskell's QuickCheck, for those who know it. In QuickCheck++, there is no <code>collect</code> and we use the more general <code>classify</code> instead (we had no idea how to implement <code>collect</code> and it seems of limited use as the following example shows).</p>
<p>Redefining the classifier as:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">string</span> classify(<span class="keyword">const</span> Elem&amp; x, <span class="keyword">const</span> Vector&amp; xs) {</div>
<div class="line">   <span class="keywordtype">string</span> s = toString(xs.size());</div>
<div class="line">   <span class="keywordflow">if</span> (xs.empty() || x &lt;= xs[0])</div>
<div class="line">      s += <span class="stringliteral">&quot;, at head&quot;</span>;</div>
<div class="line">   <span class="keywordflow">if</span> (xs.empty() || x &gt;= xs.back())</div>
<div class="line">      s += <span class="stringliteral">&quot;, at end&quot;</span>;</div>
<div class="line">   <span class="keywordflow">if</span> (!xs.empty() &amp;&amp; x &gt;= xs[0] &amp;&amp; x &lt;= xs.back())</div>
<div class="line">      s += <span class="stringliteral">&quot;, inside&quot;</span>;</div>
<div class="line">   <span class="keywordflow">return</span> s;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We now obtain:</p>
<pre class="fragment">OK, passed 100 tests.
  39% 0, at head, at end
  17% 1, at end
  14% 1, at head
   7% 2, inside
   6% 2, at end
   4% 3, inside
   3% 3, at end
   3% 2, at head
   2% 3, at head
   1% 5, inside
   1% 4, at head
   1% 4, at end, inside
   1% 3, at end, inside
   1% 1, at head, at end, inside
</pre><p>We see the problem. As the length of our vector grows, the likelihood that it is sorted decreases and empty or very small vectors are over-represented in the test input data. We will solve this using a custom generator as explained in the next section.</p>
<h2><a class="anchor" id="custom"></a>
Custom Data Generators</h2>
<p>There are two types of data generators:</p><ul>
<li>General purpose data generators are associated with a type and allows the generation of values of this type at random.</li>
<li>Special purpose data generators are associated with a property and allows the generation of randomly generated arguments for this property.</li>
</ul>
<h3><a class="anchor" id="general"></a>
General Purpose Generators</h3>
<p>General purpose generators are necessary for all types that can be received as arguments by a property. The QuickCheck++ input argument generation process relies on these generators to be defined for each type involved in a property.</p>
<p>They take the form of a function with signature <a class="el" href="namespacequickcheck.html#aea4aaf2eb80102078a0800e4c373c4af" title="Generates a boolean value randomly. ">quickcheck::generate</a>(size_t, A&amp;) where <code>A</code> is the generated type.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacequickcheck.html#aea4aaf2eb80102078a0800e4c373c4af">quickcheck::generate</a>(<span class="keywordtype">size_t</span> n, A&amp; out);</div>
</div><!-- fragment --><p>The first argument <code>n</code> is a size hint that allows QuickCheck++ to increase the size of generated values as the tests progress, in order to:</p><ul>
<li>fail preferably with shorter values which are easier to read and debug ;</li>
<li>to allow tests to be fast when you are in hurry and only ask a few while being more demanding when you have time and ask for a lot of tests.</li>
</ul>
<p>Properly used, (if you generate compound members of composite data structures with a lower size hint than the one you received), it also ensures that QuickCheck++ will not try to build an overly large or even infinite data structure.</p>
<p>The second argument <code>out</code> is a reference to be initialised to a randomly generated value.</p>
<p>For example, here is the definition of a structure and a corresponding generator:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Point {</div>
<div class="line">   <span class="keywordtype">int</span> x;</div>
<div class="line">   <span class="keywordtype">int</span> y;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacequickcheck.html#aea4aaf2eb80102078a0800e4c373c4af">generate</a>(<span class="keywordtype">size_t</span> n, Point&amp; out);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacequickcheck.html#aea4aaf2eb80102078a0800e4c373c4af">generate</a>(<span class="keywordtype">size_t</span> n, Point&amp; out)</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="namespacequickcheck.html#aea4aaf2eb80102078a0800e4c373c4af">generate</a>(n, out.x); <span class="comment">// no need to decrease n here, as int is not composite</span></div>
<div class="line">   <a class="code" href="namespacequickcheck.html#aea4aaf2eb80102078a0800e4c373c4af">generate</a>(n, out.y);</div>
<div class="line">}</div>
</div><!-- fragment --><p>We could now write and verify properties taking <code>Point</code> arguments.</p>
<h3><a class="anchor" id="special"></a>
Special Purpose Generators</h3>
<p>We have seen in our insertion example that the default general purpose generators may lead to inefficient, biased input data distribution (often when an input predicate is filtering out too many possible test cases).</p>
<p>When that occurs, one can provide its own custom generator by re-implementing the <a class="el" href="classquickcheck_1_1Property.html#a450a8c87b06589e48071a5031a1f134c" title="Generates input randomly. ">quickcheck::Property::generateInput</a> method.</p>
<p>For example, if we modify <code>PInsertKeepsSorted</code> by adding a generator:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PInsertKeepsSorted5 : <span class="keyword">public</span> Property&lt;Elem, Vector&gt; {</div>
<div class="line">   <span class="keywordtype">bool</span> holdsFor(<span class="keyword">const</span> Elem&amp; x, <span class="keyword">const</span> Vector&amp; xs) {</div>
<div class="line">      Vector ys = xs;</div>
<div class="line">      insert(x, ys);</div>
<div class="line">      <span class="keywordflow">return</span> isSorted(ys);</div>
<div class="line">   }</div>
<div class="line">   <span class="comment">// no need for the predicate anymore as we generate only valid input</span></div>
<div class="line">   <span class="comment">// bool accepts(const Elem&amp; x, const Vector&amp; xs) {</span></div>
<div class="line">   <span class="comment">//    return isSorted(xs);</span></div>
<div class="line">   <span class="comment">// }</span></div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">string</span> classify(<span class="keyword">const</span> Elem&amp; x, <span class="keyword">const</span> Vector&amp; xs) {</div>
<div class="line">      <span class="keywordtype">string</span> s = toString(xs.size());</div>
<div class="line">      <span class="keywordflow">if</span> (xs.empty() || x &lt;= xs[0])</div>
<div class="line">         s += <span class="stringliteral">&quot;, at head&quot;</span>;</div>
<div class="line">      <span class="keywordflow">if</span> (xs.empty() || x &gt;= xs.back())</div>
<div class="line">         s += <span class="stringliteral">&quot;, at end&quot;</span>;</div>
<div class="line">      <span class="keywordflow">if</span> (!xs.empty() &amp;&amp; x &gt;= xs[0] &amp;&amp; x &lt;= xs.back())</div>
<div class="line">         s += <span class="stringliteral">&quot;, inside&quot;</span>;</div>
<div class="line">      <span class="keywordflow">return</span> s;</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordtype">void</span> generateInput(<span class="keywordtype">size_t</span> n, Elem&amp; x, Vector&amp; xs) {</div>
<div class="line">      <a class="code" href="namespacequickcheck.html#aea4aaf2eb80102078a0800e4c373c4af">generate</a>(n, x);</div>
<div class="line">      <a class="code" href="namespacequickcheck.html#aea4aaf2eb80102078a0800e4c373c4af">generate</a>(n, xs);</div>
<div class="line">      sort(xs.begin(), xs.end());</div>
<div class="line">   }</div>
<div class="line">};</div>
</div><!-- fragment --><p>We now obtain the much better distribution:</p>
<pre class="fragment">OK, passed 100 tests.
  6% 0, at head, at end
  4% 9, inside
  4% 27, inside
  4% 19, inside
  4% 15, inside
  3% 8, inside
  3% 8, at end
  3% 7, inside
  3% 5, inside
  3% 5, at head, inside
  3% 32, inside
  3% 2, at end
  3% 11, inside
  2% 5, at head
  2% 42, inside
  2% 4, inside
  2% 34, inside
  2% 31, inside
  2% 29, inside
  ...
</pre><h3><a class="anchor" id="data"></a>
Data Generator Primitives</h3>
<p>QuickCheck++ comes with generators for all primitive types and provides functions to help you write your own generators easily (see <a class="el" href="generate_8hh.html" title="Defines the data generator interface. ">quickcheck/generate.hh</a>).</p>
<h2><a class="anchor" id="printing"></a>
Printing Property Names</h2>
<p>If you would like to print the property under examination before its results, you can use the helper function template <a class="el" href="namespacequickcheck.html#aac7db4fe302ae0e4f16648d25c2c4747" title="Creates and verifies a property. ">quickcheck::check</a> which takes a message to print as its first argument and a property class as its template argument. This function will print the message, instantiate the property and verify it. Apart from the message, it takes the same arguments as <a class="el" href="classquickcheck_1_1PropertyBase.html#af3c938e7c6d91cb2acc7a5f46bcd2ee0" title="Checks this property. ">quickcheck::Property::check</a>.</p>
<p>For example, with the definitions of section <a class="el" href="index.html#defining">Defining Properties</a> and <a class="el" href="index.html#verifying">Verifying Properties</a></p>
<div class="fragment"><div class="line">check&lt;PReverseCancelsReverse&gt;(<span class="stringliteral">&quot;that reverse cancels reverse&quot;</span>);</div>
<div class="line">check&lt;PReverseCancelsReverse&gt;(<span class="stringliteral">&quot;that reverse cancels reverse&quot;</span>, 200);</div>
<div class="line">check&lt;PReverseCancelsReverse&gt;(<span class="stringliteral">&quot;that reverse cancels reverse&quot;</span>, 200, 600);</div>
<div class="line">check&lt;PReverseIsIdentity&gt;(<span class="stringliteral">&quot;that reverse is identity&quot;</span>);</div>
</div><!-- fragment --><p>would print</p>
<pre class="fragment">* Checking that reverse cancels reverse...
OK, passed 100 tests.

* Checking that reverse cancels reverse (200)...
OK, passed 200 tests.

* Checking that reverse cancels reverse (200, 600)...
OK, passed 200 tests.

* Checking that reverse is identity...
Falsifiable after 1 tests for input:
  0: [-2, -1, 1]
</pre><h2><a class="anchor" id="verbose"></a>
Verbose Checking</h2>
<p>QuickCheck++ presents you with an example of faulty input when a properties fails by returning <code>false</code>, but what if your program get stuck in an infinite loop or crashes with a segfault?</p>
<p>If one of these cases occurs, you need QuickCheck++ to print the input arguments <em>before</em> the tests, because it will not have the occasion to do it afterwards. You can do precisely this by asking QuickCheck++ to do a <em>verbose</em> check when calling <a class="el" href="classquickcheck_1_1PropertyBase.html#af3c938e7c6d91cb2acc7a5f46bcd2ee0" title="Checks this property. ">quickcheck::Property::check</a>.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> getTheAnswer(<span class="keywordtype">int</span> i)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">while</span> (i &lt; 0) {</div>
<div class="line">      <span class="comment">// eat CPU cycles until interrupted</span></div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">return</span> 42;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>PBottom : Property&lt;int&gt; {</div>
<div class="line">   <span class="keywordtype">bool</span> holdsFor(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; i) {</div>
<div class="line">      <span class="keywordflow">return</span> getTheAnswer(i) == 42;</div>
<div class="line">   }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">check&lt;PBottom&gt;(<span class="stringliteral">&quot;this function is stupid&quot;</span>, 100, 0, <span class="keyword">true</span>);</div>
</div><!-- fragment --><p>would output something like</p>
<pre class="fragment">* Checking that this property is stupid...
Test 0:
  0: 1
Test 1:
  0: -3
^C
</pre><p>where <code>^C</code> stands for the Ctrl-C necessary to interrupt the process.</p>
<p>Verbose checking can also be useful to visually verify what the random generated input looks like.</p>
<h2><a class="anchor" id="fixed"></a>
Fixed Test Cases</h2>
<p>Although randomly generated test cases have their utility, one should not rely on them too much to find corner cases (especially for large values, as these could not be practically generated by the framework). Instead, one should also provide carefully chosen test cases that put the tested code under stress.</p>
<p>Other reasons to use fixed test cases includes regression testing and common use cases (to be sure at least these work).</p>
<p>To use QuickCheck++ with fixed test cases as in other classical <em>xUnit</em> testing frameworks, use the <a class="el" href="classquickcheck_1_1Property.html#a7d959a983f02ebea7d4b38a7c51becd3" title="Adds a fixed test case for with the given arguments. ">quickcheck::Property::addFixed</a> method. Each input data added through this function will be used as input for your property before any randomly-generated input each time <a class="el" href="classquickcheck_1_1PropertyBase.html#af3c938e7c6d91cb2acc7a5f46bcd2ee0" title="Checks this property. ">quickcheck::Property::check</a> is called.</p>
<p>For example, imagine the following iterative squaring function (<em>e.g.</em> for an architecture where multiplication is costly):</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">unsigned</span> iterativeSquare(<span class="keywordtype">unsigned</span> n)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">unsigned</span> res = 0;</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i)</div>
<div class="line">      res += n;</div>
<div class="line">   <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
</div><!-- fragment --><p>One property of a squared number is that it is divisible by its square root:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PSquareDivisibleByRoot : <span class="keyword">public</span> Property&lt;unsigned&gt; {</div>
<div class="line">   <span class="keywordtype">bool</span> holdsFor(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; i) {</div>
<div class="line">      <span class="keywordflow">return</span> unsigned(sqrt(iterativeSquare(i))) == i;</div>
<div class="line">   }</div>
<div class="line">};</div>
</div><!-- fragment --><p>If we try this, all seems to fit:</p>
<div class="fragment"><div class="line">PSquareDivisibleByRoot squareDivisibleByRoot;</div>
<div class="line">squareDivisibleByRoot.check();</div>
</div><!-- fragment --><p>gives</p>
<pre class="fragment">OK, passed 100 tests.
</pre><p>However, our function is not safe. It simply pass the tests because all generated values for the argument are relatively small compared to the range of unsigned integers. Let's add one test case for the biggest unsigned integer:</p>
<div class="fragment"><div class="line">squareDivisibleByRoot.addFixed(std::numeric_limits&lt;unsigned&gt;::max());</div>
<div class="line">squareDivisibleByRoot.check();</div>
</div><!-- fragment --><p>This time, we obtain</p>
<pre class="fragment">Falsifiable after 1 tests for input:
  0: 4294967295
</pre><p>indicating that our function is partial in its argument (we should document and assert accepted input values).</p>
<h1><a class="anchor" id="how2"></a>
How to Contribute?</h1>
<h2><a class="anchor" id="test"></a>
Test</h2>
<p>We are interested in feedback about utility of QuickCheck++ and its design. If you have time to give it a try, and you think something is great/stupid/could be improved, let us know.</p>
<p>You can contact us by mail at the address mentioned in the source or just drop a comment on <a href="http://devmusings.legiasoft.com/quickcheck-like-framework-for-cpp">our blog</a>.</p>
<h2><a class="anchor" id="code"></a>
Code</h2>
<p>QuickCheck++ is currently just a quick hack by a non-expert C++ programmer. Code can be improved, and it should surely be extended to make the framework more complete.</p>
<p>If you like QuickCheck++ and you got some spare time (or if you had to implement things for your own use), we're gladly accepting patches (send them to the address mentioned in the source).</p>
<h2><a class="anchor" id="promote"></a>
Promote</h2>
<p>If you think QuickCheck++ is great, tell others about it. The more people know about the framework, the more people may find it useful and the more useful it becomes! </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 14 2015 17:30:41 for QuickCheck++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
